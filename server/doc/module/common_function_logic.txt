common function:

request check:

1. open app: client will get a _xrsf from server, to mark this phone.

2. guarantee request from user:

    1. avoid xrsf: 
        _xrsf [auto implement by tornado], client should post _xrsf.
    
    2. secure_cookie: 
        guarantee the cookie is safe.

get access_token:

    * after request check.

    * get user_id from client.

    * check has if login?

    * get access_token from USER_DICT[user_id]. or get access_token from PUBLIC_TOKEN.

--------now, suppose it has been done by php, now we guarantee the request is from user itself.----

login:

    1. after request check.

    2. avoid repeat login:
        server will get user_id from client.
        server has a USER_DICT, check if USER_DICT[user_id] is empty.
            empty: login.
            not empty: repeat login, error.
    
openAppSeachCookie['phoneid'] or try to login and has check his password.--->
             has get phone_id--->empty--->get_current_cookie('phone_id')[which f @tornado.web.authenticated]
                            
                             --->not empty--> the same ---> login
                                          
                                          --> different -->change _xrsf. USER_DICT['phone_id'](xrsf,access_token)--->login

    3. check username and password.
        get username password access_token from mysql.
        check it.

    4. success login:
        change USER_DICT[user_id] = [access_token].

register:
    
    * after request check.

    * check username is exist in mysql?

    * get information from client, php has a variable call "user_amount", after server start, get it from the amount of user_table in mysql. to store the next user_id in mysql. --- to avoid several accout register in the same time.

-----now, suppose it has been done by php, we have user information, sourse_id.-------
    
    * register in Umeng, return access_token.

    * send access_token to php, store it in php.

logout:

    * after request check.

    * USER_DICT[user_id] = empty.


------feed List------



get feed_list:

    * after request check.
    * get access_token.
    * request: 
        * count: return feed amount
        * page: page num.
        * days: set the recent day. default is recent 7 days
    * response:

get feed_detail:

    * after request check.
    * get access_token.
    
    * get feed_content:
        request:
            * count??
            * page:?
            * feed_id.
    * get comment_list:
        request:
            count:
            comment_uid: no need, return comment only create by uid in this feed.
            feed_id:
            page:
            order:seq or -seq or like_count or -like_count
    * get hot comment_list:
        request:
            feed_id:


------opt to feed--------

opt comment:
    set comment:
        content: comment comment
        img_str: url of img [default]
        feed_id:
        reply_id:no need. -- reply to another comment
        reply_uid:no need. -- reply to another user.
    delete comment:
        request:
            comment_id


opt like:

opt collect:

opt tramist:----opt include "at" operate.
    



------ my feed --------

get my_feed_list:[todo 1.0]

= opt upload, delete, modify:

    * after request check, get access_token.

        + upload:
            * upload image, get its url.
                + ref about upload image: http://blog.chinaunix.net/
            * request:
                * img_str[url]
                * title
                * image_uRls:{'origin':'原图', '360':'360宽', '750':'750宽'}  
                * custom:? none.
                * content:
                * location:

        + delete:
            * request: feed_id. 

        + can not been modify.


= opt inform num:

    * after request check, get access_token.
             
        + unread information: comment, like, been collected, at, [no tramist].
            * request: none



= opt get_my_list:

    * after request check, get access_token.

        + comment list:
            * received comment list:
                request:
                    count:not need. default as 30
                    type:reseived
                    page:page num

            * send comment list:[need?]

        + like list:
            request:
                count:
                page

        + notice list[by administor]
            * request:
                count:no need in client, default as 30
                page: page num.



---follow----

get follow_list[todo 2.0]



count----> global?


all of request from client should post a _xrsf value.
all of request, server should check if USER_DICT still has this user.[when user change its password, the status will been clear to zero.]